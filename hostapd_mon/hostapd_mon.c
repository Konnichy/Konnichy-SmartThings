/**
 * hostapd_mon
 *
 * This program listens to events generated by hostapd on its control socket and forwards
 * JSON-formatted connect/disconnect events to an HTTP server.
 *
 * Author: Yann Fleutot (Konnichy)
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License. You may obtain a copy of the License at:
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 *  on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License
 *  for the specific language governing permissions and limitations under the License.
 *
 */


#include <stdio.h>          // printtf(), size_t, perror(), fprintf(), snprintf(), sprintf()
#include <errno.h>          // perror()
#include <string.h>         // strlen(), strstr(), strchr()
#include <stdlib.h>         // system()
#include <sys/socket.h>     // socket()
#include <netdb.h>          // gethostbyname()
#include <unistd.h>         // sleep(), write()

#include "wpa_ctrl.h"


#define MAX_REPLY_LENGTH            256
#define EVENTS_TO_FORWARD           { "AP-STA-CONNECTED", "AP-STA-DISCONNECTED" }
#define NB_OF_EVENTS_TO_FORWARD     2
#define MAX_JSON_LENGTH             256
#define RECONNECT_DELAY             2


struct context {
    char * control_path;
    char * destination_url;
    struct wpa_ctrl * event_ctrl;
};
    
struct decoded_url {
    char host[51];
    unsigned int port;
    char path[101];
};

int open_event_channel(struct context * context) {
    if (context->event_ctrl != NULL) {
        // control channel is already open
        return 0;
    }
    
    context->event_ctrl = wpa_ctrl_open(context->control_path);
	if (context->event_ctrl == NULL) {
		perror("wpa_ctrl_open()");
		return -1;
	}

    if (wpa_ctrl_attach(context->event_ctrl) < 0) {
        perror("wpa_ctrl_attach()");
        return -1;
    }

    printf("Connected to hostapd\n");
    return 0;
}

void close_event_channel(struct context * context) {
    if (wpa_ctrl_detach(context->event_ctrl) < 0)
        perror("wpa_ctrl_detach()");
    
    wpa_ctrl_close(context->event_ctrl);

    context->event_ctrl = NULL;
}

void receive_event(struct context * context, char * buffer, size_t buffer_len) {
    // Never stop retrying to receive events
    while (1) {
        // Make sure hostapd's control channel is open
        if (open_event_channel(context) < 0) {
            sleep(RECONNECT_DELAY);
            continue;
        }

        if (wpa_ctrl_recv(context->event_ctrl, buffer, &buffer_len) < 0) {
            perror("wpa_ctrl_recv()");
            close_event_channel(context);
            sleep(RECONNECT_DELAY);
            continue;
        }

        // Success
        break;
    }

    buffer[buffer_len] = '\0';
}

int is_subscribed_event(const char * event) {
    char * events_to_forward[NB_OF_EVENTS_TO_FORWARD] = EVENTS_TO_FORWARD;
    
    for (int event_nb=0 ; event_nb<NB_OF_EVENTS_TO_FORWARD ; event_nb++) {
        if (strcmp(event, events_to_forward[event_nb]) == 0) {
            return 1;
        }
    }

    return 0;
}

int create_json_message(const char * event, const char * mac_address, char * buffer, size_t buffer_size) {
    size_t size;

    size = snprintf(buffer, buffer_size, "{ \"event\":\"%s\", \"mac_address\":\"%s\" }", event, mac_address);
    if (size < 0) {
        fprintf(stderr, "create_json_message(): Message is longer than buffer\n");
        return -1;
    }

    return 0;
}

int decode_url(const char * url, struct decoded_url * decoded_url) {
    int rc;

    /* Source: https://stackoverflow.com/a/726214
     */
    rc = sscanf(url, "http://%50[^:]:%d%100[^\n]",
                decoded_url->host,
                &decoded_url->port,
                decoded_url->path);
    if (rc != 3) {
        fprintf(stderr, "decode_url(): URL format not supported\n");
        return -1;
    }

    return 0;
}

int send_buffer(int sock, const char * buffer, int buffer_len) {
    int bytes_nb;
    
    do {
        bytes_nb = write(sock, buffer, buffer_len);
        if (bytes_nb < 0) {
            perror("write()");
            return -1;
        }
        /* if (bytes_nb == 0) */
        /*     break; */
        buffer += bytes_nb;
        buffer_len -= bytes_nb;
    } while (buffer_len > 0);

    return 0;
}

int send_event(const char * url, const char * http_body) {
    // Create the socket
    int sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
        perror("socket()");
        return -1;
    }

    // Decode the URL
    struct decoded_url destination;
    if (decode_url(url, &destination) < 0)
        return -1;
    
    // Resolve the hostname
    struct hostent * server;
    server = gethostbyname(destination.host);
    if (server == NULL) {
        perror("gethostbyname()");
        return -1;
    }
    
    // Connect to the host
    struct sockaddr_in server_address;
    memset(&server_address, 0, sizeof(server_address));
    server_address.sin_family = AF_INET;
    server_address.sin_port = htons(destination.port);
    memcpy(&server_address.sin_addr.s_addr, server->h_addr, server->h_length);
    if (connect(sock, (struct sockaddr *) &server_address, sizeof(server_address)) < 0) {
        perror("connect()");
        return -1;
    }

    // Send the message
    char http_header[500];
    if (sprintf(http_header, "POST %s HTTP/1.1\r\nHost: %s:%d\r\nContent-Type: application/json\r\nContent-Length: %d\r\n\r\n", destination.path, destination.host, destination.port, (int) strlen(http_body)) < 0) {
        perror("sprintf()");
        return -1;
    }
    if (send_buffer(sock, http_header, strlen(http_header)) < 0)
        return -1;
    if (send_buffer(sock, http_body, strlen(http_body)) < 0)
        return -1;

    // Close the connection
    if (close(sock) < 0) {
        perror("close()");
        return -1;
    }
    
    return 0;
}

void split_event(char * buffer, char ** event, char ** data) {
    *event = &buffer[3];
    char * separator = strchr(*event, ' ');
    *separator = '\0';
    *data = separator + 1;    
}
                 
void process_events(struct context * context) {
    char buffer[MAX_REPLY_LENGTH + 1];
    char * event;
    char * data;
    char json_message[MAX_JSON_LENGTH + 1];
    
    while (1) {

        // Receive an event
        receive_event(context, buffer, sizeof(buffer));
        split_event(buffer, &event, &data);

        // If hostapd is exiting, close the control channel
        if (strcmp(event, "AP-DISABLED") == 0) {
            printf("Access point is shutting down, will try to reconnect periodically\n");
            close_event_channel(context);
            continue;
        }
        
        // Filter unwanted events out
        if (!is_subscribed_event(event))
            continue;

        // Create a JSON event message
        if (create_json_message(event, data, json_message, sizeof(json_message)) < 0)
            continue;

        // Send the JSON event message to the destination URL
        printf("Sending event %s to %s\n", json_message, context->destination_url);
        if (send_event(context->destination_url, json_message) < 0)
            continue;
    }
}

int main(int argc, char *argv[]) {
    struct context context;
    
    // Initialize context
    if (argc != 3) {
        printf("Usage: %s <path_to_control_socket> <destination_url>\n", argv[0]);
        return 1;
    }
    context.control_path = argv[1];
    context.destination_url = argv[2];
    context.event_ctrl = NULL;

    // Process events in loop
    process_events(&context);

    // Execution only reaches this point in case of unrecoverable error
	return 3;
}
